<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Venelin Mitov" />

<meta name="date" content="2025-09-01" />

<title>Getting Started with the PCMBase R-package</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
margin-bottom: 0em;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Getting Started with the PCMBase
R-package</h1>
<h4 class="author">Venelin Mitov</h4>
<h4 class="date">2025-09-01</h4>


<div id="TOC">
<ul>
<li><a href="#data" id="toc-data">Data</a></li>
<li><a href="#models" id="toc-models">Models</a>
<ul>
<li><a href="#the-mathcalg_linv-family-of-models" id="toc-the-mathcalg_linv-family-of-models">The <span class="math inline">\(\mathcal{G}_{LInv}\)</span>-family of
models</a></li>
<li><a href="#example-ornstein-uhlenbeck-model-types" id="toc-example-ornstein-uhlenbeck-model-types">Example:
Ornstein-Uhlenbeck model types</a></li>
<li><a href="#groups-of-model-types" id="toc-groups-of-model-types">Groups of model types</a></li>
<li><a href="#creating-pcm-objects" id="toc-creating-pcm-objects">Creating PCM objects</a></li>
<li><a href="#model-regimes" id="toc-model-regimes">Model
regimes</a></li>
<li><a href="#printing-models-in-the-form-of-a-table" id="toc-printing-models-in-the-form-of-a-table">Printing models in the
form of a table</a></li>
<li><a href="#mixed-gaussian-models" id="toc-mixed-gaussian-models">Mixed Gaussian models</a></li>
</ul></li>
<li><a href="#simulating-data-on-a-phylogenetic-tree" id="toc-simulating-data-on-a-phylogenetic-tree">Simulating data on a
phylogenetic tree</a></li>
<li><a href="#calculating-likelihoods" id="toc-calculating-likelihoods">Calculating likelihoods</a></li>
<li><a href="#references" id="toc-references">References</a></li>
</ul>
</div>

<!--
# Copyright 2016-2022 Venelin Mitov
#
# This file is part of PCMBase.
#
# PCMBase is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# PCMBase is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PCMBase.  If not, see <http://www.gnu.org/licenses/>.
-->
<div id="data" class="section level1">
<h1>Data</h1>
<p>The input data for the phylogenetic comparative methods covered in
the PCMBase package consists of a phylogenetic tree of <span class="math inline">\(N\)</span> tips and a <span class="math inline">\(k\times N\)</span> matrix, <span class="math inline">\(X\)</span> of observed trait-values, where <span class="math inline">\(k\)</span> is the number of traits. The matrix
<span class="math inline">\(X\)</span> can contain <code>NA</code>s
corresponding to missing measurements and <code>NaN</code>’s
corresponding to non-existing traits for some of the tips.</p>
</div>
<div id="models" class="section level1">
<h1>Models</h1>
<p>Given a number of traits <span class="math inline">\(k\)</span>, a
<em>model</em> is defined as a set of parameters with dimensionality
possibly depending on <span class="math inline">\(k\)</span> and a rule
stating how these parameters are used to calculate the model likelihood
for an observed tree and data and/or to simulate data along a tree.
Often, we use the term <em>model type</em> to denote a family of models
sharing the same rule.</p>
<div id="the-mathcalg_linv-family-of-models" class="section level2">
<h2>The <span class="math inline">\(\mathcal{G}_{LInv}\)</span>-family
of models</h2>
<p>Currently, PCMBase supports Gaussian model types from the so called
<span class="math inline">\(\mathcal{G}_{LInv}\)</span>-family <span class="citation">(Mitov et al. 2019)</span>. Specifically, these are
models representing branching stochastic processes and satisfying the
following two conditions <span class="citation">(Mitov et al.
2019)</span>:</p>
<ol style="list-style-type: decimal">
<li><p>after a branching point on the tree the traits evolve
independently in the two descending lineages,</p></li>
<li><p>the distribution of the trait <span class="math inline">\(\vec{X}\)</span>, at time <span class="math inline">\(t\)</span> conditional on the value at time <span class="math inline">\(s &lt; t\)</span> is Gaussian with the mean and
variance satisfying</p>
<p>2.a The expectation depends linearly on the ancestral trait value,
i.e. <span class="math inline">\(\text{E}\big[{\vec{X}(t) \vert
\vec{X}(s)}\big] = \vec{\omega}_{s,t} + \mathbf{\Phi}_{s,t}
\vec{X}(s)\)</span>;</p>
<p>2.b The variance is invariant (does not depend on) with respect to
the ancestral trait, i.e. <span class="math inline">\(\text{V}\big[{\vec{X}(t) \vert \vec{X}(s)}\big] =
\mathbf{V}_{s,t}\)</span>,</p></li>
</ol>
<p>where <span class="math inline">\(\vec{\omega}\)</span> and the
matrices <span class="math inline">\(\mathbf{\Phi}\)</span>, <span class="math inline">\(\mathbf{V}\)</span> may depend on <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> but do not depend on the previous
trajectory of the trait <span class="math inline">\(\vec{X}(\cdot)\)</span>.</p>
</div>
<div id="example-ornstein-uhlenbeck-model-types" class="section level2">
<h2>Example: Ornstein-Uhlenbeck model types</h2>
<p>As an example, let’s consider a model representing a <span class="math inline">\(k\)</span>-variate Ornstein-Uhlenbeck branching
stochastic process. This is defined by the following stochastic
differential equation: <span class="math display">\[\begin{equation}\label{eq:mammals:OUprocess}
d\vec{X}(t)=\mathbf{H}\big(\vec{\theta}-\vec{X}(t)\big)dt+\mathbf{\mathbf{\Sigma}}_{\chi}
dW(t).
\end{equation}\]</span> In the above equation, <span class="math inline">\(\vec{X}(t)\)</span> is a <span class="math inline">\(k\)</span>-dimensional real vector, <span class="math inline">\(\mathbf{H}\)</span> is a <span class="math inline">\(k\times k\)</span>-dimensional eigen-decomposable
real matrix, <span class="math inline">\(\vec{\theta}\)</span> is a
<span class="math inline">\(k\)</span>-dimensional real vector, <span class="math inline">\(\mathbf{\Sigma}_{\chi}\)</span> is a <span class="math inline">\(k\times k\)</span>-dimensional real positive
definite matrix and <span class="math inline">\(W(t)\)</span> denotes
the <span class="math inline">\(k\)</span>-dimensional standard Wiener
process.</p>
<p>Biologically, <span class="math inline">\(\vec{X}(t)\)</span> denotes
the mean values of <span class="math inline">\(k\)</span> continuous
traits in a species at a time <span class="math inline">\(t\)</span>
from the root, the parameter <span class="math inline">\(\mathbf{\Sigma}=\mathbf{\Sigma}_{\chi}\mathbf{\Sigma}_{\chi}^T\)</span>
defines the magnitude and shape of the momentary fluctuations in the
mean vector due to genetic drift, the matrix <span class="math inline">\(\mathbf{H}\)</span> and the vector <span class="math inline">\(\vec{\theta}\)</span> specify the trajectory of
the population mean through time. When <span class="math inline">\(\mathbf{H}\)</span> is the zero matrix, the
process is equivalent to a Brownian motion process and the parameter
<span class="math inline">\(\vec{\theta}\)</span> is irrelevant. When
<span class="math inline">\(\mathbf{H}\)</span> has strictly positive
eigenvalues, the population mean converges in the long term towards
<span class="math inline">\(\vec{\theta}\)</span>, although the
trajectory of this convergence can be complex.</p>
<p>So, the OU-model defines the following set of parameters:</p>
<ul>
<li><span class="math inline">\(\vec{X}_{0}\)</span> (coded
<code>X0</code>) : a <span class="math inline">\(k\)</span>-vector of
initial values;</li>
<li><span class="math inline">\(\mathbf{H}\)</span> (coded
<code>H</code>) : a <span class="math inline">\(k\times k\)</span>
matrix denoting the selection strength of the process;</li>
<li><span class="math inline">\(\vec{\theta}\)</span> (coded
<code>Theta</code>) : a <span class="math inline">\(k\)</span>-vector of
long-term optimal trait values;</li>
<li><span class="math inline">\(\mathbf{\Sigma}_{\chi}\)</span> : (coded
<code>Sigma_x</code>) : a <span class="math inline">\(k\times k\)</span>
matrix denoting the an upper triangular factor or the stochastic drift
variance-covariances;
<!-- - $\mathbf{\Sigma}_{e,\chi}$ (coded `Sigmae_x`) : a $k\times k$ matrix denoting the Choleski factor of the non-genetic (non-heritable) variance covariance; --></li>
</ul>
<p>The rule defining how the parameters of the OU-model are used to
calculate the model likelihood and to simulate data consists in the
definition of the functions <span class="math inline">\(\vec{\omega}\)</span> and matrices <span class="math inline">\(\mathbf{\Phi}\)</span>, <span class="math inline">\(\mathbf{V}\)</span> <span class="citation">(Mitov
et al. 2019)</span>: <span class="math display">\[\begin{equation}\label{eq:mammals:omegaPhiVOU}
\begin{array}{l}
\vec{\omega}_{s,t}=\bigg(\mathbf{I}-\text{Exp}\big(-(t-s)\mathbf{H}\big)\bigg)\vec{\theta}
\\
\mathbf{\Phi}_{s,t}=\text{Exp}(-(t-s)\mathbf{H}) \\
\mathbf{V}_{s,t}=\int_{0}^{t-s}\text{Exp}(-v\mathbf{H})(\mathbf{\Sigma}_{\chi}\mathbf{\Sigma}_{\chi}^T)\text{Exp}(-v\mathbf{H}^T)dv
\end{array}
\end{equation}\]</span></p>
<p>Together, <span class="math inline">\(\vec{X}_{0}\)</span>, <span class="math inline">\(\vec{\omega}\)</span>, <span class="math inline">\(\mathbf{\Phi}\)</span>, <span class="math inline">\(\mathbf{V}\)</span> and the tree define a <span class="math inline">\(kN\)</span>-variate Gaussian distribution for the
vector of trait values at the tips. This is the defining property of all
Gaussian phylogenetic models. Hence, calculating the model likelihood is
equivalent to calculating the density of this Gaussian distribution at
observed trait values, and simulating data under the model is equivalent
to drawing a random sample from this distribution. The functions
<code>PCMMean()</code> and <code>PCMVar()</code> allow to calculate the
mean <span class="math inline">\(kN\)</span>-vector and the <span class="math inline">\(kN\times kN\)</span> variance covariance matrix of
this distribution. This can be useful, in particular, to compare two
models by calculating a distance metric such as the Mahalanobis
distance, or the Bhattacharyya distance. However, for big <span class="math inline">\(k\)</span> and/or <span class="math inline">\(N\)</span>, it is inefficient to use these
functions in combination with a general purpose multivariate normal
implementation (e.g. the <code>mvtnorm::dmvnorm</code> and
<code>mvtnorm::rmvnorm</code>), to calculate the likelihood or simulate
data assuming an OU model. The main purpose of PCMBase package is to
provide a generic and computationally efficient way to perform these two
operations.</p>
</div>
<div id="groups-of-model-types" class="section level2">
<h2>Groups of model types</h2>
<p>It is convenient to group model types into smaller subsets with named
elements. This allows to use simple names, such as letters, as aliases
for otherwise very long model type names. For example, the PCMBase
package defines a subset of six so called “default model types”, which
are commonly used in macroevolutionary studies. These are model types
based on parameterizations of the <span class="math inline">\(k\)</span>-variate Ornstein-Uhlenbeck (OU)
process. All of these six models restrict <span class="math inline">\(\mathbf{H}\)</span> to have non-negative
eigenvalues - a negative eigenvalue of <span class="math inline">\(\mathbf{H}\)</span> transforms the process into
repulsion with respect to <span class="math inline">\(\vec{\theta}\)</span>, which, while biologically
plausible, is not identifiable in a ultrametric tree. The six default
models are defined as follows:</p>
<ul>
<li><span class="math inline">\(BM_{A}\)</span> (<span class="math inline">\(\mathbf{H}=0\)</span>, diagonal <span class="math inline">\(\mathbf{\Sigma}\)</span>): BM, uncorrelated
traits;</li>
<li><span class="math inline">\(BM_{B}\)</span> (<span class="math inline">\(\mathbf{H}=0\)</span>, symmetric <span class="math inline">\(\mathbf{\Sigma}\)</span>): BM, correlated
traits;</li>
<li><span class="math inline">\(OU_{C}\)</span> (diagonal <span class="math inline">\(\mathbf{H}\)</span>, diagonal <span class="math inline">\(\mathbf{\Sigma}\)</span>): OU, uncorrelated
traits;</li>
<li><span class="math inline">\(OU_{D}\)</span> (diagonal <span class="math inline">\(\mathbf{H}\)</span>, symmetric <span class="math inline">\(\mathbf{\Sigma}\)</span>): OU, correlated traits,
but simple (diagonal) selection strength matrix;</li>
<li><span class="math inline">\(OU_{E}\)</span> (symmetric <span class="math inline">\(\mathbf{H}\)</span>, symmetric <span class="math inline">\(\mathbf{\Sigma}\)</span>): An OU with non-diagonal
symmetric <span class="math inline">\(\mathbf{H}\)</span> and
non-diagonal symmetric <span class="math inline">\(\mathbf{\Sigma}\)</span>;</li>
<li><span class="math inline">\(OU_{F}\)</span> (asymmetric <span class="math inline">\(\mathbf{H}\)</span>, symmetric <span class="math inline">\(\mathbf{\Sigma}\)</span>): An OU with non-diagonal
asymmetric <span class="math inline">\(\mathbf{H}\)</span> and
non-diagonal symmetric <span class="math inline">\(\mathbf{\Sigma}\)</span>;</li>
</ul>
<p>Calling the function <code>PCMDefaultModelTypes()</code> returns a
named vector of the technical class-names for these six models:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># scroll to the right in the following listing to see the full model type names </span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="co"># and their corresponding alias:</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">PCMDefaultModelTypes</span>()</span></code></pre></div>
<pre><code>##                                                                                                                                                                                A 
##                                                                                                      &quot;BM__Global_X0__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x&quot; 
##                                                                                                                                                                                B 
##                                                                                   &quot;BM__Global_X0__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x&quot; 
##                                                                                                                                                                                C 
##                                       &quot;OU__Global_X0__Schur_Diagonal_WithNonNegativeDiagonal_Transformable_H__Theta__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x&quot; 
##                                                                                                                                                                                D 
##                    &quot;OU__Global_X0__Schur_Diagonal_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x&quot; 
##                                                                                                                                                                                E 
## &quot;OU__Global_X0__Schur_UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x&quot; 
##                                                                                                                                                                                F 
##                             &quot;OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x&quot;</code></pre>
<p>The PCMBase package comes with numerous other predefined model types.
At present, all these are members of the <span class="math inline">\(\mathcal{G}_{LInv}\)</span>-family. A list of
these model types is returned from calling the function
<code>PCMModels()</code>.</p>
<p>For each model type, it is possible to check how the conditional
distribution of <span class="math inline">\(\vec{X}\)</span> at the end
of a time interval of length <span class="math inline">\(t\)</span> is
defined from an ancestral value <span class="math inline">\(X_{0}\)</span>. In particular, for <span class="math inline">\(\mathcal{G}_{LInv}\)</span> models, this is the
definition of the functions <span class="math inline">\(\vec{\omega}\)</span>, <span class="math inline">\(\mathbf{\Phi}\)</span> and <span class="math inline">\(\mathbf{V}\)</span>. For example,</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">PCMFindMethod</span>(<span class="fu">PCMDefaultModelTypes</span>()[<span class="st">&quot;A&quot;</span>], <span class="st">&quot;PCMCond&quot;</span>)</span></code></pre></div>
<pre><code>## function (tree, model, r = 1, metaI = PCMInfo(NULL, tree, model, 
##     verbose = verbose), verbose = FALSE) 
## {
##     Sigma_x &lt;- GetSigma_x(model, &quot;Sigma&quot;, r)
##     Sigma &lt;- Sigma_x %*% t(Sigma_x)
##     if (!is.null(model$Sigmae_x)) {
##         Sigmae_x &lt;- GetSigma_x(model, &quot;Sigmae&quot;, r)
##         Sigmae &lt;- Sigmae_x %*% t(Sigmae_x)
##     }
##     else {
##         Sigmae &lt;- NULL
##     }
##     V &lt;- PCMCondVOU(matrix(0, nrow(Sigma), ncol(Sigma)), Sigma, 
##         Sigmae)
##     omega &lt;- function(t, edgeIndex, metaI) {
##         rep(0, nrow(Sigma))
##     }
##     Phi &lt;- function(t, edgeIndex, metaI, e_Ht = NULL) {
##         diag(nrow(Sigma))
##     }
##     list(omega = omega, Phi = Phi, V = V)
## }
## &lt;bytecode: 0x56412542dea8&gt;
## &lt;environment: namespace:PCMBase&gt;</code></pre>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># The complex maths is implemented in the function PCMCondVOU. You can see its </span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="co"># R-code by typing :</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="co"># PCMBase::PCMCondVOU</span></span></code></pre></div>
</div>
<div id="creating-pcm-objects" class="section level2">
<h2>Creating PCM objects</h2>
<p>In the computer memory, models are represented by S3 objects,
i.e. ordinary R-lists with a class attribute. The base S3 class of all
models is called <code>&quot;PCM&quot;</code>, which is inherited by more specific
model-classes. Let us create a BM PCM for two traits:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>modelBM <span class="ot">&lt;-</span> <span class="fu">PCM</span>(<span class="at">model =</span> <span class="st">&quot;BM&quot;</span>, <span class="at">k =</span> <span class="dv">2</span>)</span></code></pre></div>
<p>Printing the model object shows a short verbal description, the
S3-class, the number of traits, k, the number of numerical parameters of
the model, p, the model regimes and the current values of the parameters
for each regime (more on regimes in the next sub-section):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>modelBM</span></code></pre></div>
<pre><code>## Brownian motion model
## S3 class: BM, GaussianPCM, PCM; k=2; p=8; regimes: 1. Parameters/sub-models:
## X0 (VectorParameter, _Global, numeric; trait values at the root):
## [1] 0 0
## Sigma_x (MatrixParameter, _UpperTriangularWithDiagonal, _WithNonNegativeDiagonal; factor of the unit-time variance rate):
## , , 1
## 
##      [,1] [,2]
## [1,]    0    0
## [2,]    0    0
## 
## Sigmae_x (MatrixParameter, _UpperTriangularWithDiagonal, _WithNonNegativeDiagonal; factor of the non-heritable variance or the variance of the measurement error):
## , , 1
## 
##      [,1] [,2]
## [1,]    0    0
## [2,]    0    0
## 
## </code></pre>
<p>One may wonder why in the above description, p = 8 instead of 10 (see
also <code>?PCMParamCount</code>). The reason is that both, the matrix
Sigma and the matrix Sigmae, are symmetric matrices and their matching
off-diagonal elements are counted only one time.</p>
</div>
<div id="model-regimes" class="section level2">
<h2>Model regimes</h2>
<p>Model <em>regimes</em> are different models associated with different
parts of the phylogenetic tree. This is a powerful concept allowing to
model different evolutionary modes on different lineages on the tree.
Let us create a 2-trait BM model with two regimes called a and b:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>modelBM.ab <span class="ot">&lt;-</span> <span class="fu">PCM</span>(<span class="st">&quot;BM&quot;</span>, <span class="at">k =</span> <span class="dv">2</span>, <span class="at">regimes =</span> <span class="fu">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>))</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>modelBM.ab</span></code></pre></div>
<pre><code>## Brownian motion model
## S3 class: BM, GaussianPCM, PCM; k=2; p=14; regimes: a, b. Parameters/sub-models:
## X0 (VectorParameter, _Global, numeric; trait values at the root):
## [1] 0 0
## Sigma_x (MatrixParameter, _UpperTriangularWithDiagonal, _WithNonNegativeDiagonal; factor of the unit-time variance rate):
## , , a
## 
##      [,1] [,2]
## [1,]    0    0
## [2,]    0    0
## 
## , , b
## 
##      [,1] [,2]
## [1,]    0    0
## [2,]    0    0
## 
## Sigmae_x (MatrixParameter, _UpperTriangularWithDiagonal, _WithNonNegativeDiagonal; factor of the non-heritable variance or the variance of the measurement error):
## , , a
## 
##      [,1] [,2]
## [1,]    0    0
## [2,]    0    0
## 
## , , b
## 
##      [,1] [,2]
## [1,]    0    0
## [2,]    0    0
## 
## </code></pre>
<p>Now, we can set some different values for the parameters of the model
we’ve just created. First, let us specify an initial value vector
different from the default 0-vector:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>modelBM.ab<span class="sc">$</span>X0[] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">5</span>, <span class="dv">2</span>)</span></code></pre></div>
<p>X0 is defined as a parameter with S3 class
<code>class(modelBM.ab$X0)</code>. This specifies that <code>X0</code>
is global vector parameter shared by all model regimes. This is also the
reason, why the number of parameters is not the double of the number of
parameters in the first model:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">PCMParamCount</span>(modelBM)</span></code></pre></div>
<pre><code>## [1] 8</code></pre>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">PCMParamCount</span>(modelBM.ab)</span></code></pre></div>
<pre><code>## [1] 14</code></pre>
<p>The other parameters, Sigma_x and Sigmae_x are local for each
regime:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="co"># in regime &#39;a&#39; the traits evolve according to two independent BM processes (starting from the global vecto X0).</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>modelBM.ab<span class="sc">$</span>Sigma_x[,, <span class="st">&quot;a&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">rbind</span>(<span class="fu">c</span>(<span class="fl">1.6</span>, <span class="dv">0</span>),</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>                                  <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">2.4</span>))</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>modelBM.ab<span class="sc">$</span>Sigmae_x[,, <span class="st">&quot;a&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">rbind</span>(<span class="fu">c</span>(.<span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>                                   <span class="fu">c</span>(<span class="dv">0</span>, .<span class="dv">4</span>))</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="co"># in regime &#39;b&#39; there is a correlation between the traits</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>modelBM.ab<span class="sc">$</span>Sigma_x[,, <span class="st">&quot;b&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">rbind</span>(<span class="fu">c</span>(<span class="fl">1.6</span>, .<span class="dv">8</span>),</span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a>                                  <span class="fu">c</span>(.<span class="dv">8</span>, <span class="fl">2.4</span>))</span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a>modelBM.ab<span class="sc">$</span>Sigmae_x[,, <span class="st">&quot;b&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">rbind</span>(<span class="fu">c</span>(.<span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a>                                   <span class="fu">c</span>(<span class="dv">0</span>, .<span class="dv">4</span>))</span></code></pre></div>
<p>The above way of setting values for model parameters, while human
readable, is not handy during model fitting procedures, such as
likelihood maximization. Thus, there is another way to set (or get) the
model parameter values from a numerical vector:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>param <span class="ot">&lt;-</span> <span class="fu">double</span>(<span class="fu">PCMParamCount</span>(modelBM.ab))</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a><span class="co"># load the current model parameters into param</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a><span class="fu">PCMParamLoadOrStore</span>(modelBM.ab, param, <span class="at">offset=</span><span class="dv">0</span>, <span class="at">load=</span><span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## [1] 14</code></pre>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="fu">print</span>(param)</span></code></pre></div>
<pre><code>##  [1] 5.0 2.0 1.6 0.0 2.4 1.6 0.8 2.4 0.1 0.0 0.4 0.1 0.0 0.4</code></pre>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="co"># modify slightly the model parameters</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>param2 <span class="ot">&lt;-</span> <span class="fu">jitter</span>(param)</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a><span class="fu">print</span>(param2)</span></code></pre></div>
<pre><code>##  [1]  4.98242236  1.99660534  1.61499716 -0.01045085  2.39059634  1.58800242
##  [7]  0.78258155  2.41805470  0.10678817 -0.01255452  0.38603198  0.08008689
## [13]  0.01371539  0.39886305</code></pre>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="co"># set the new parameter vector</span></span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a><span class="fu">PCMParamLoadOrStore</span>(modelBM.ab, param2, <span class="at">offset =</span> <span class="dv">0</span>, <span class="at">load=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 14</code></pre>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="fu">print</span>(modelBM.ab)</span></code></pre></div>
<pre><code>## Brownian motion model
## S3 class: BM, GaussianPCM, PCM; k=2; p=14; regimes: a, b. Parameters/sub-models:
## X0 (VectorParameter, _Global, numeric; trait values at the root):
## [1] 4.982422 1.996605
## Sigma_x (MatrixParameter, _UpperTriangularWithDiagonal, _WithNonNegativeDiagonal; factor of the unit-time variance rate):
## , , a
## 
##          [,1]        [,2]
## [1,] 1.614997 -0.01045085
## [2,] 0.000000  2.39059634
## 
## , , b
## 
##          [,1]      [,2]
## [1,] 1.588002 0.7825816
## [2,] 0.800000 2.4180547
## 
## Sigmae_x (MatrixParameter, _UpperTriangularWithDiagonal, _WithNonNegativeDiagonal; factor of the non-heritable variance or the variance of the measurement error):
## , , a
## 
##           [,1]        [,2]
## [1,] 0.1067882 -0.01255452
## [2,] 0.0000000  0.38603198
## 
## , , b
## 
##            [,1]       [,2]
## [1,] 0.08008689 0.01371539
## [2,] 0.00000000 0.39886305
## 
## </code></pre>
</div>
<div id="printing-models-in-the-form-of-a-table" class="section level2">
<h2>Printing models in the form of a table</h2>
<p>It can be handy to print the parameters of a model in the form of a
table with rows corresponding to the different regimes. For that purpose
we use the <code>PCMTable()</code> function, which generates a
<code>PCMTable</code> object for a given <code>PCM</code> object. The
<code>PCMTable</code> S3 class inherits from <code>data.table</code> and
implements a print method that allows for beautiful formatting of matrix
and vector parameters. Here is an example:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="fu">options</span>(<span class="at">digits =</span> <span class="dv">2</span>)</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">PCMTable</span>(modelBM.ab), <span class="at">xtable =</span> <span class="cn">TRUE</span>, <span class="at">type=</span><span class="st">&quot;html&quot;</span>)</span></code></pre></div>
<table border="1">
<tr>
<th>
regime
</th>
<th>
<span class="math inline">\(X0\)</span>
</th>
<th>
<span class="math inline">\(\Sigma\)</span>
</th>
<th>
<span class="math inline">\(\Sigma_{e}\)</span>
</th>
</tr>
<tr>
<td align="right">
:global:
</td>
<td align="right">
<span class="math inline">\(\begin{bmatrix}{}  4.98 \\   2.00
\\   \end{bmatrix}\)</span>
</td>
<td align="right">
</td>
<td align="right">
</td>
</tr>
<br />

<tr>
<td align="right">
a
</td>
<td align="right">
</td>
<td align="right">
<span class="math inline">\(\begin{bmatrix}{}  2.61 &amp; -0.02
\\   -0.02 &amp; 5.71 \\   \end{bmatrix}\)</span>
</td>
<td align="right">
<span class="math inline">\(\begin{bmatrix}{}  0.01 &amp; -0.00
\\   -0.00 &amp; 0.15 \\   \end{bmatrix}\)</span>
</td>
</tr>
<br />

<tr>
<td align="right">
b
</td>
<td align="right">
</td>
<td align="right">
<span class="math inline">\(\begin{bmatrix}{}  3.13 &amp; 3.16 \\   3.16
&amp; 6.49 \\   \end{bmatrix}\)</span>
</td>
<td align="right">
<span class="math inline">\(\begin{bmatrix}{}  0.01 &amp; 0.01 \\   0.01
&amp; 0.16 \\   \end{bmatrix}\)</span>
</td>
</tr>
</table>
<p>Check the help-page for the <code>PCMTable</code>-function for more
details.</p>
</div>
<div id="mixed-gaussian-models" class="section level2">
<h2>Mixed Gaussian models</h2>
<p>One of the features of the package is the possibility to specify
models in which different types of processes are associated with
different regimes. We call these “mixed Gaussian” models. To create a
mixed Gaussian model, we use the constructor function
<code>MixedGaussian</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>model.OU.BM <span class="ot">&lt;-</span> <span class="fu">MixedGaussian</span>(</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>  <span class="at">k =</span> <span class="dv">3</span>, </span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a>  <span class="at">modelTypes =</span> <span class="fu">c</span>(</span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a>    <span class="at">BM =</span> <span class="fu">paste0</span>(<span class="st">&quot;BM&quot;</span>,</span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a>    <span class="st">&quot;__Omitted_X0&quot;</span>,</span>
<span id="cb28-6"><a href="#cb28-6" tabindex="-1"></a>    <span class="st">&quot;__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x&quot;</span>,</span>
<span id="cb28-7"><a href="#cb28-7" tabindex="-1"></a>    <span class="st">&quot;__Omitted_Sigmae_x&quot;</span>),</span>
<span id="cb28-8"><a href="#cb28-8" tabindex="-1"></a>    <span class="at">OU =</span> <span class="fu">paste0</span>(<span class="st">&quot;OU&quot;</span>,</span>
<span id="cb28-9"><a href="#cb28-9" tabindex="-1"></a>    <span class="st">&quot;__Omitted_X0&quot;</span>,</span>
<span id="cb28-10"><a href="#cb28-10" tabindex="-1"></a>    <span class="st">&quot;__H&quot;</span>,</span>
<span id="cb28-11"><a href="#cb28-11" tabindex="-1"></a>    <span class="st">&quot;__Theta&quot;</span>,</span>
<span id="cb28-12"><a href="#cb28-12" tabindex="-1"></a>    <span class="st">&quot;__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x&quot;</span>,</span>
<span id="cb28-13"><a href="#cb28-13" tabindex="-1"></a>    <span class="st">&quot;__Omitted_Sigmae_x&quot;</span>)), </span>
<span id="cb28-14"><a href="#cb28-14" tabindex="-1"></a>  <span class="at">mapping =</span> <span class="fu">c</span>(<span class="at">a =</span> <span class="dv">2</span>, <span class="at">b =</span> <span class="dv">1</span>), </span>
<span id="cb28-15"><a href="#cb28-15" tabindex="-1"></a>  <span class="at">Sigmae_x =</span> <span class="fu">structure</span>(</span>
<span id="cb28-16"><a href="#cb28-16" tabindex="-1"></a>    <span class="dv">0</span>, </span>
<span id="cb28-17"><a href="#cb28-17" tabindex="-1"></a>    <span class="at">class =</span> <span class="fu">c</span>(<span class="st">&quot;MatrixParameter&quot;</span>, <span class="st">&quot;_Omitted&quot;</span>), </span>
<span id="cb28-18"><a href="#cb28-18" tabindex="-1"></a>    <span class="at">description =</span> <span class="st">&quot;upper triangular factor of the non-phylogenetic variance-covariance&quot;</span>))</span></code></pre></div>
<p>In the above, snippet, notice the long names for the BM and the OU
model types. These are the model types that can be mapped to regimes. It
is important to notice that both of these model types omit the parameter
<code>X0</code>, which is a global parameter shared by all regimes.
Similarly the two model types omit the parameter <code>Sigmae_x</code>.
However, in this example, we specify that the whole mixed Gaussian model
does not have a <code>Sigmae_x</code> parameter, i.e. the model assumes
that the trait variation is completely explainable by the mixed Gaussian
phylogenetic process and there is no non-heritable component. For more
information on model parametrizations, see the <a href="https://venelin.github.io/PCMBase/articles/PCMParam.html">PCMBase
parameterizations</a> guide. For further information on mixed Gaussian
models, see the <code>?MixedGaussian</code> help page.</p>
<p>We can set the parameters of the model manually as follows:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>model.OU.BM<span class="sc">$</span>X0[] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="cn">NA</span>, <span class="cn">NA</span>, <span class="cn">NA</span>)</span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>model.OU.BM<span class="sc">$</span><span class="st">`</span><span class="at">a</span><span class="st">`</span><span class="sc">$</span>H[,,<span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">cbind</span>(</span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a>  <span class="fu">c</span>(.<span class="dv">1</span>, <span class="sc">-</span>.<span class="dv">7</span>, .<span class="dv">6</span>), </span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a>  <span class="fu">c</span>(<span class="fl">1.3</span>, <span class="fl">2.2</span>, <span class="sc">-</span><span class="fl">1.4</span>), </span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a>  <span class="fu">c</span>(<span class="fl">0.8</span>, <span class="fl">0.2</span>, <span class="fl">0.9</span>))</span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a>model.OU.BM<span class="sc">$</span><span class="st">`</span><span class="at">a</span><span class="st">`</span><span class="sc">$</span>Theta[] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">1.3</span>, <span class="sc">-</span>.<span class="dv">5</span>, .<span class="dv">2</span>)</span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a>model.OU.BM<span class="sc">$</span><span class="st">`</span><span class="at">a</span><span class="st">`</span><span class="sc">$</span>Sigma_x[,,<span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">cbind</span>(</span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a>  <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>), </span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a>  <span class="fu">c</span>(<span class="fl">1.0</span>, <span class="fl">0.5</span>, <span class="dv">0</span>), </span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a>  <span class="fu">c</span>(<span class="fl">0.3</span>, <span class="sc">-</span>.<span class="dv">8</span>, <span class="dv">1</span>))</span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" tabindex="-1"></a>model.OU.BM<span class="sc">$</span><span class="st">`</span><span class="at">b</span><span class="st">`</span><span class="sc">$</span>Sigma_x[,,<span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">cbind</span>(</span>
<span id="cb29-13"><a href="#cb29-13" tabindex="-1"></a>  <span class="fu">c</span>(<span class="fl">0.8</span>, <span class="dv">0</span>, <span class="dv">0</span>), </span>
<span id="cb29-14"><a href="#cb29-14" tabindex="-1"></a>  <span class="fu">c</span>(<span class="dv">1</span>, <span class="fl">0.3</span>, <span class="dv">0</span>), </span>
<span id="cb29-15"><a href="#cb29-15" tabindex="-1"></a>  <span class="fu">c</span>(<span class="fl">0.4</span>, <span class="fl">0.5</span>, <span class="fl">0.3</span>))</span></code></pre></div>
<p>We can print the mixed Gaussian model as a table:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">PCMTable</span>(model.OU.BM), <span class="at">xtable =</span> <span class="cn">TRUE</span>, <span class="at">type=</span><span class="st">&quot;html&quot;</span>)</span></code></pre></div>
<table border="1">
<tr>
<th>
regime
</th>
<th>
type
</th>
<th>
<span class="math inline">\(X0\)</span>
</th>
<th>
<span class="math inline">\(H\)</span>
</th>
<th>
<span class="math inline">\(\Theta\)</span>
</th>
<th>
<span class="math inline">\(\Sigma\)</span>
</th>
</tr>
<tr>
<td align="right">
:global:
</td>
<td align="right">
NA
</td>
<td align="right">
<span class="math inline">\(\begin{bmatrix}{}  . \\   . \\   .
\\   \end{bmatrix}\)</span>
</td>
<td align="right">
</td>
<td align="right">
</td>
<td align="right">
</td>
</tr>
<br />

<tr>
<td align="right">
a
</td>
<td align="right">
OU
</td>
<td align="right">
</td>
<td align="right">
<span class="math inline">\(\begin{bmatrix}{}  0.10 &amp; 1.30 &amp;
0.80 \\   -0.70 &amp; 2.20 &amp; 0.20 \\   0.60 &amp; -1.40 &amp; 0.90
\\   \end{bmatrix}\)</span>
</td>
<td align="right">
<span class="math inline">\(\begin{bmatrix}{}  1.30 \\   -0.50 \\   0.20
\\   \end{bmatrix}\)</span>
</td>
<td align="right">
<span class="math inline">\(\begin{bmatrix}{}  2.09 &amp; 0.26 &amp;
0.30 \\   0.26 &amp; 0.89 &amp; -0.80 \\   0.30 &amp; -0.80 &amp; 1.00
\\   \end{bmatrix}\)</span>
</td>
</tr>
<br />

<tr>
<td align="right">
b
</td>
<td align="right">
BM
</td>
<td align="right">
</td>
<td align="right">
</td>
<td align="right">
</td>
<td align="right">
<span class="math inline">\(\begin{bmatrix}{}  1.80 &amp; 0.50 &amp;
0.12 \\   0.50 &amp; 0.34 &amp; 0.15 \\   0.12 &amp; 0.15 &amp; 0.09
\\   \end{bmatrix}\)</span>
</td>
</tr>
</table>
</div>
</div>
<div id="simulating-data-on-a-phylogenetic-tree" class="section level1">
<h1>Simulating data on a phylogenetic tree</h1>
<p>The first functionality of the PCMBase package is to provide an easy
way to simulate multiple trait data on a tree under a given (possibly
multiple regime) PCM.</p>
<p>For this example, first we simulate a birth death tree with two parts
“a” and “b” using the <code>ape</code> R-package:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="co"># make results reproducible</span></span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2</span>, <span class="at">kind =</span> <span class="st">&quot;Mersenne-Twister&quot;</span>, <span class="at">normal.kind =</span> <span class="st">&quot;Inversion&quot;</span>)</span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a><span class="co"># number of regimes</span></span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a>R <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a><span class="co"># number of extant tips</span></span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" tabindex="-1"></a>tree.a <span class="ot">&lt;-</span> <span class="fu">PCMTree</span>(<span class="fu">rtree</span>(<span class="at">n=</span>N))</span>
<span id="cb31-11"><a href="#cb31-11" tabindex="-1"></a><span class="fu">PCMTreeSetLabels</span>(tree.a)</span>
<span id="cb31-12"><a href="#cb31-12" tabindex="-1"></a><span class="fu">PCMTreeSetPartRegimes</span>(tree.a, <span class="at">part.regime =</span> <span class="fu">c</span>(<span class="st">`</span><span class="at">101</span><span class="st">`</span> <span class="ot">=</span> <span class="st">&quot;a&quot;</span>), <span class="at">setPartition =</span> <span class="cn">TRUE</span>)</span>
<span id="cb31-13"><a href="#cb31-13" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" tabindex="-1"></a>lstDesc <span class="ot">&lt;-</span> <span class="fu">PCMTreeListDescendants</span>(tree.a)</span>
<span id="cb31-15"><a href="#cb31-15" tabindex="-1"></a>splitNode <span class="ot">&lt;-</span> <span class="fu">names</span>(lstDesc)[<span class="fu">which</span>(<span class="fu">sapply</span>(lstDesc, length) <span class="sc">&gt;</span> N<span class="sc">/</span><span class="dv">2</span> <span class="sc">&amp;</span> <span class="fu">sapply</span>(lstDesc, length) <span class="sc">&lt;</span> <span class="dv">2</span><span class="sc">*</span>N<span class="sc">/</span><span class="dv">3</span>)][<span class="dv">1</span>]</span>
<span id="cb31-16"><a href="#cb31-16" tabindex="-1"></a></span>
<span id="cb31-17"><a href="#cb31-17" tabindex="-1"></a>tree.ab <span class="ot">&lt;-</span> <span class="fu">PCMTreeInsertSingletons</span>(</span>
<span id="cb31-18"><a href="#cb31-18" tabindex="-1"></a>  tree.a, <span class="at">nodes =</span> <span class="fu">as.integer</span>(splitNode), </span>
<span id="cb31-19"><a href="#cb31-19" tabindex="-1"></a>  <span class="at">positions =</span> <span class="fu">PCMTreeGetBranchLength</span>(tree.a, <span class="fu">as.integer</span>(splitNode))<span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb31-20"><a href="#cb31-20" tabindex="-1"></a><span class="fu">PCMTreeSetPartRegimes</span>(</span>
<span id="cb31-21"><a href="#cb31-21" tabindex="-1"></a>  tree.ab,</span>
<span id="cb31-22"><a href="#cb31-22" tabindex="-1"></a>  <span class="at">part.regime =</span> <span class="fu">structure</span>(<span class="fu">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>), <span class="at">names =</span> <span class="fu">as.character</span>(<span class="fu">c</span>(N<span class="sc">+</span><span class="dv">1</span>, splitNode))), </span>
<span id="cb31-23"><a href="#cb31-23" tabindex="-1"></a>  <span class="at">setPartition =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="cf">if</span>(<span class="fu">requireNamespace</span>(<span class="st">&quot;ggtree&quot;</span>)) {</span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a>  palette <span class="ot">&lt;-</span> <span class="fu">PCMColorPalette</span>(<span class="dv">2</span>, <span class="fu">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>))</span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a>  </span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a>  <span class="co"># Plot the tree with branches colored according to the regimes.</span></span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a>  <span class="co"># The following code works only if the ggtree package is installed, which is not on CRAN. </span></span>
<span id="cb32-6"><a href="#cb32-6" tabindex="-1"></a>  <span class="co"># The tree would not be depicted correctly if ggtree is not installed.</span></span>
<span id="cb32-7"><a href="#cb32-7" tabindex="-1"></a>  plTree <span class="ot">&lt;-</span> <span class="fu">PCMTreePlot</span>(tree.ab)</span>
<span id="cb32-8"><a href="#cb32-8" tabindex="-1"></a>  plTree <span class="ot">&lt;-</span> plTree <span class="sc">+</span> ggtree<span class="sc">::</span><span class="fu">geom_nodelab</span>(<span class="at">size =</span> <span class="dv">2</span>) </span>
<span id="cb32-9"><a href="#cb32-9" tabindex="-1"></a></span>
<span id="cb32-10"><a href="#cb32-10" tabindex="-1"></a>  plTree</span>
<span id="cb32-11"><a href="#cb32-11" tabindex="-1"></a>}</span></code></pre></div>
<p>Now we can simulate data on the tree using the modelBM.ab$X0 as a
starting value:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a>traits <span class="ot">&lt;-</span> <span class="fu">PCMSim</span>(tree.ab, modelBM.ab, modelBM.ab<span class="sc">$</span>X0)</span></code></pre></div>
</div>
<div id="calculating-likelihoods" class="section level1">
<h1>Calculating likelihoods</h1>
<p>Calculating a model likelihood for a given tree and data is the other
key functionality of the PCMBase package.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="fu">PCMLik</span>(traits, tree.ab, modelBM.ab)</span></code></pre></div>
<pre><code>## [1] -414
## attr(,&quot;X0&quot;)
## [1] 5 2</code></pre>
<p>For faster and repeated likelihood evaluation, I recommend creating a
likelihood function for a given data, tree and model object. Passing
this function object to <code>optim</code> would save the need for
pre-processing the data and tree at every likelihood evaluation.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="co"># a function of a numerical parameter vector:</span></span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a>likFun <span class="ot">&lt;-</span> <span class="fu">PCMCreateLikelihood</span>(traits, tree.ab, modelBM.ab)</span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" tabindex="-1"></a><span class="fu">likFun</span>(param2)</span></code></pre></div>
<pre><code>## [1] -414
## attr(,&quot;X0&quot;)
## [1] 5 2</code></pre>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-Mitov:2018fl" class="csl-entry">
Mitov, Venelin, Krzysztof Bartoszek, Georgios Asimomitis, and Tanja
Stadler. 2019. <span>“<span class="nocase">Fast likelihood calculation
for multivariate Gaussian phylogenetic models with
shifts</span>.”</span> <em>Theor. Popul. Biol.</em>, December. <a href="https://doi.org/10.1016/j.tpb.2019.11.005">https://doi.org/10.1016/j.tpb.2019.11.005</a>.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
